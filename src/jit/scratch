    macro_rules! jump {
      (imm26) => {
        {
          Box::new(move |vm| {
            let imm26 = get_imm26(op);
            let pc_hi_bits = vm.r3000.pc() & 0xf000_0000;
            let shifted_imm26 = imm26 * 4;
            let dest = pc_hi_bits + shifted_imm26;
            log!("jumping to (PC & 0xf0000000) + ({:#x} * 4)\n  = {:#x} + {:#x}\n  = {:#x} after the delay slot",
                      imm26, pc_hi_bits, shifted_imm26, dest);
            Some(dest)
          })
        }
      };
      (rs) => {
        {
          Box::new(move |vm| {
            let rs = vm.r3000.nth_reg(get_rs(op));
            if rs & 0x0000_0003 != 0 {
              let pc = vm.r3000.pc_mut();
              *pc = vm.cop0.generate_exception(Cop0Exception::LoadAddress, *pc);
              log!("ignoring jumping to R{} = {:#x} and generating an exception", get_rs(op), rs);
              None
            } else {
              log!("jumping to R{} = {:#x} after the delay slot", get_rs(op), rs);
              Some(rs)
            }
          })
        }
      };
      (rs $cmp:tt rt) => {
        {
          Box::new(move |vm| {
            let rt = vm.r3000.nth_reg(get_rt(op));
            let rs = vm.r3000.nth_reg(get_rs(op));
            if rs $cmp rt {
              let imm16 = get_imm16(op);
              let pc = vm.r3000.pc();
              let inc = ((imm16.half_sign_extended() as i32) * 4) as u32;
              let dest = pc.wrapping_add(inc);
              log!("jumping to PC + ({:#x} * 4) = {:#x} + {:#x} = {:#x} after the delay slot\n  since R{} {} R{} -> {:#x} {} {:#x}",
                        imm16, pc, inc, dest, get_rs(op), stringify!($cmp), get_rt(op), rs, stringify!($cmp), rt);
              Some(dest)
            } else {
              log!("skipping jump since R{} {} R{} -> {:#x} {} {:#x} is false",
                        get_rs(op), stringify!($cmp), get_rt(op), rs, stringify!($cmp), rt);
              None
            }
          })
        }
      };
      (rs $cmp:tt 0) => {
        {
          Box::new(move |vm| {
            let rs = vm.r3000.nth_reg(get_rs(op));
            log!("op16");
            if (rs as i32) $cmp 0 {
              let imm16 = get_imm16(op);
              let pc = vm.r3000.pc();
              let inc = ((imm16 as i16) * 4) as u32;
              let dest = pc.wrapping_add(inc);
              Some(dest)
            } else {
              None
            }
          })
        }
      };
    }
    macro_rules! call {
      (imm26) => {
        {
          Box::new(move |vm| {
            let ret = vm.r3000.pc().wrapping_add(4);
            vm.modified_register = vm.r3000.ra_mut().maybe_set(ret);
            log!("R31 = {:#x}", ret);
            let imm26 = get_imm26(op);
            let pc_hi_bits = vm.r3000.pc() & 0xf000_0000;
            let shifted_imm26 = imm26 * 4;
            let dest = pc_hi_bits + shifted_imm26;
            log!("jumping to (PC & 0xf0000000) + ({:#x} * 4)\n  = {:#x} + {:#x}\n  = {:#x} after the delay slot",
                      imm26, pc_hi_bits, shifted_imm26, dest);
            Some(dest)
          })
        }
      };
      (rs) => {
        {
          Box::new(move |vm| {
            let result = vm.r3000.pc().wrapping_add(4);
            let rd = vm.r3000.nth_reg_mut(get_rd(op));
            vm.modified_register = rd.maybe_set(result);
            log!("op18");
            let rs = vm.r3000.nth_reg(get_rs(op));
            if rs & 0x0000_0003 != 0 {
              let pc = vm.r3000.pc_mut();
              *pc = vm.cop0.generate_exception(Cop0Exception::LoadAddress, *pc);
              log!("ignoring jumping to R{} = {:#x} and generating an exception", get_rs(op), rs);
              None
            } else {
              log!("jumping to R{} = {:#x} after the delay slot", get_rs(op), rs);
              Some(rs)
            }
          })
        }
      };
      (rs $cmp:tt rt) => {
        {
          Box::new(move |vm| {
            let rt = vm.r3000.nth_reg(get_rt(op));
            let rs = vm.r3000.nth_reg(get_rs(op));
            log!("op19");
            if *rs $cmp *rt {
              let ret = vm.r3000.pc().wrapping_add(4);
              vm.modified_register = vm.r3000.ra_mut().maybe_set(ret);
              let imm16 = get_imm16(op);
              let pc = vm.r3000.pc();
              let inc = ((imm16 as i16) * 4) as u32;
              let dest = pc.wrapping_add(inc);
              Some(dest)
            } else {
              None
            }
          })
        }
      };
      (rs $cmp:tt 0) => {
        {
          Box::new(move |vm| {
            let rs = vm.r3000.nth_reg(get_rs(op));
            log!("op20");
            if (rs as i32) $cmp 0 {
              let ret = vm.r3000.pc().wrapping_add(4);
              vm.modified_register = vm.r3000.ra_mut().maybe_set(ret);
              let imm16 = get_imm16(op);
              let pc = vm.r3000.pc();
              let dest = pc + (imm16 * 4);
              Some(dest)
            } else {
              None
            }
          })
        }
      };
    }

