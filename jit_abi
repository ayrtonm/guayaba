all x64 registers except %rsp should be used to store MIPS registers
MIPS registers are prioritized according to the number of times they're used
and mapped to x64 registers in the following orders
%eax
%ecx
%edx
%ebx
%ebp
%esi
%edi
%r8d
%r9d
%r10d
%r11d
%r12d
%r13d
%r14d
%r15d

since %r15d should contain the least frequently used MIPS (except in the case of overflow) let's use it for calling functions
functions called must conform to the System V amd64 ABI so arguments must be passed in %rdi, %rsi, %rdx

if we just need to check a bit in cop0, let's use %r15 then if necessary %r14, %r13, etc...
|------------------------|
| console::read_byte_se  |
|------------------------|
| console::read_half_se  |
|------------------------|
| console::read_byte     |
|------------------------|
| console::read_half     |
|------------------------|
| console::read_word     |
|------------------------|
| console::write_byte    |
|------------------------|
| console::write_half    |
|------------------------|
| console::write_word    |
|------------------------|
| &console               |
|------------------------|
| &cop0 reg array        |
|------------------------|
| &R3000 reg array       |
|------------------------| <--- maximum %rsp
| R3000 reg overflow x16 | <--- these are optional
|------------------------| <--- minimum %rsp
           ||
           ||
           \/ stack grows downward

register loading process
------------------------
movq mips_reg_addr r15

;save mips_reg_addr for later
push r15

;make space on the stack
addq -4 * count_overflow rsp

;write [mips_reg_addr + mips_reg_idx] to [rsp + stack_offset]
for stack_offset in overflow_mappings() {
  movl mips_reg_idx(r15) r14
  movl r14 stack_offset(rsp)
}

;write [mips_reg_addr + mips_reg_idx] to x
;r15 is the last x so it's ok to trash its value
for x in loaded_mappings() {
  movl mips_reg_idx(r15) x
}

register saving process
-----------------------
if r15 in use {
  push r15
}
;load mips_reg_addr into r15
movq (count_overflow * 4)(rsp) r15

for x in loaded_mappings().filter(|y| y != 15) {
  movl x mips_reg_idx(r15)
}

for stack_offset in overflow_mappings() {
  movl stack_offset(rsp) r14
  movl r14 mips_reg_idx(r15)
}
if r15 was in use {
  ;pop the value that was in r15 into r14
  pop r14
  ;write the value previously in r15 to the MIPS reg array
  movl r14 mips_reg_idx(r15)
}
;clear overflow registers and mips_reg_addr from stack
;the immediate operand does not match the one in the addq in load_registers since
;this includes the `push r15` at the start of load_registers as well
addq (4 * count_overflow) + 8 rsp
